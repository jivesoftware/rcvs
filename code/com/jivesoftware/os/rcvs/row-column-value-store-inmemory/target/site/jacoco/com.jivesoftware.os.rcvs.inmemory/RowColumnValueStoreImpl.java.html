<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RowColumnValueStoreImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">row-column-value-store-inmemory</a> &gt; <a href="index.html" class="el_package">com.jivesoftware.os.rcvs.inmemory</a> &gt; <span class="el_source">RowColumnValueStoreImpl.java</span></div><h1>RowColumnValueStoreImpl.java</h1><pre class="source lang-java linenums">/*
 * $Revision$
 * $Date$
 *
 * Copyright (C) 1999-$year$ Jive Software. All rights reserved.
 *
 * This software is the proprietary information of Jive Software. Use is subject to license terms.
 */
package com.jivesoftware.os.rcvs.inmemory;

import com.jivesoftware.os.jive.utils.base.interfaces.CallbackStream;
import com.jivesoftware.os.jive.utils.base.util.locks.StripingLocksProvider;
import com.jivesoftware.os.jive.utils.logger.MetricLogger;
import com.jivesoftware.os.jive.utils.logger.MetricLoggerFactory;
import com.jivesoftware.os.rcvs.api.CallbackStreamException;
import com.jivesoftware.os.rcvs.api.ColumnValueAndTimestamp;
import com.jivesoftware.os.rcvs.api.KeyedColumnValueCallbackStream;
import com.jivesoftware.os.rcvs.api.RowColumValueTimestampAdd;
import com.jivesoftware.os.rcvs.api.RowColumnTimestampRemove;
import com.jivesoftware.os.rcvs.api.RowColumnValueStore;
import com.jivesoftware.os.rcvs.api.TenantIdAndRow;
import com.jivesoftware.os.rcvs.api.TenantKeyedColumnValueCallbackStream;
import com.jivesoftware.os.rcvs.api.TenantRowColumValueTimestampAdd;
import com.jivesoftware.os.rcvs.api.TenantRowColumnTimestampRemove;
import com.jivesoftware.os.rcvs.api.ValueStoreMarshaller;
import com.jivesoftware.os.rcvs.api.timestamper.Timestamper;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NavigableMap;
import java.util.concurrent.ConcurrentSkipListMap;

/**
 * In-memory implementation of RowColumnValueStore generic interface. There are no timestamps/versions involved. Only the value from the last Put for a given
 * (rowKey, columnKey) is kept. In any method that has a Timestamper argument, that argument is ignored. In any method that has an Integer overrideConsistency,
 * that argument is ignored.
 *
 * @param &lt;T&gt;
 * @param &lt;S&gt;
 * @param &lt;K&gt;
 * @param &lt;V&gt;
 * @author jonathan
 */
public class RowColumnValueStoreImpl&lt;T, S, K, V&gt; implements RowColumnValueStore&lt;T, S, K, V, RuntimeException&gt; {

<span class="fc" id="L51">    private static final MetricLogger LOG = MetricLoggerFactory.getLogger();</span>
<span class="fc" id="L52">    private final Map&lt;T, NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt;&gt; tenantIdStores = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="fc" id="L53">    private final StripingLocksProvider&lt;S&gt; rowLocks = new StripingLocksProvider&lt;&gt;(128);</span>

    /**
     *
     */
<span class="fc" id="L58">    public RowColumnValueStoreImpl() {</span>
<span class="fc" id="L59">    }</span>

    private NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; getStore(T tenantId) {
<span class="fc" id="L62">        synchronized (tenantIdStores) {</span>
<span class="fc" id="L63">            NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = tenantIdStores.get(tenantId);</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">            if (store == null) {</span>
<span class="fc" id="L65">                store = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="fc" id="L66">                tenantIdStores.put(tenantId, store);</span>
            }
<span class="fc" id="L68">            return store;</span>
<span class="nc" id="L69">        }</span>
    }

    @Override
    public void add(T tenantId, S rowKey, K columnKey, V columnValue, Integer timeToLiveInSeconds, Timestamper overrideTimestamper) {
<span class="fc" id="L74">        NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(tenantId);</span>
<span class="fc" id="L75">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc" id="L76">            NavigableMap&lt;K, Timestamped&lt;V&gt;&gt; map = store.get(rowKey);</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            if (map == null) {</span>
                // todo should use sortedMap to more closely mimic cassandra impl
<span class="fc" id="L79">                map = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="fc" id="L80">                store.put(rowKey, map);</span>
            }
<span class="fc" id="L82">            Timestamped&lt;V&gt; got = map.get(columnKey);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">            if (got == null) {</span>
<span class="fc" id="L84">                got = new Timestamped&lt;&gt;();</span>
<span class="fc" id="L85">                map.put(columnKey, got);</span>
            }
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">            got.set(columnValue, overrideTimestamper == null ? System.currentTimeMillis() : overrideTimestamper.get());</span>

<span class="pc" id="L89">        }</span>
<span class="fc" id="L90">    }</span>

    @Override
    public boolean addIfNotExists(T tenantId, S rowKey, K columnKey, V columnValue, Integer timeToLiveInSeconds, Timestamper overrideTimestamper) {
<span class="fc" id="L94">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc" id="L95">            V currentVal = get(tenantId, rowKey, columnKey, null, null);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">            if (currentVal == null) {</span>
<span class="fc" id="L97">                add(tenantId, rowKey, columnKey, columnValue, timeToLiveInSeconds, overrideTimestamper);</span>
<span class="fc" id="L98">                return true;</span>
            } else {
<span class="fc" id="L100">                return false;</span>
            }
<span class="nc" id="L102">        }</span>
    }

    @Override
    public boolean replaceIfEqualToExpected(T tenantId, S rowKey, K columnKey, V columnValue, V expectedValue, Integer timeToLiveInSeconds,
        Timestamper overrideTimestamper) throws RuntimeException {
<span class="nc" id="L108">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="nc" id="L109">            V currentVal = get(tenantId, rowKey, columnKey, null, null);</span>
<span class="nc bnc" id="L110" title="All 4 branches missed.">            if (expectedValue != null &amp;&amp; !expectedValue.equals(currentVal)) {</span>
<span class="nc" id="L111">                return false;</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">            } else if (expectedValue == null &amp;&amp; currentVal != null) {</span>
<span class="nc" id="L113">                return false;</span>
            }

<span class="nc" id="L116">            add(tenantId, rowKey, columnKey, columnValue, timeToLiveInSeconds, overrideTimestamper);</span>
<span class="nc" id="L117">            return true;</span>
<span class="nc" id="L118">        }</span>
    }

    @Override
    public V get(T tenantId, S rowKey, K columnKey, Integer overrideNumberOfRetries, Integer overrideConsistency) {
<span class="fc" id="L123">        NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(tenantId);</span>
<span class="fc" id="L124">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc" id="L125">            Map&lt;K, Timestamped&lt;V&gt;&gt; map = store.get(rowKey);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (map == null) {</span>
<span class="fc" id="L127">                return null;</span>
            }
<span class="fc" id="L129">            Timestamped&lt;V&gt; got = map.get(columnKey);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (got != null) {</span>
<span class="fc" id="L131">                return got.getValue();</span>
            }
<span class="fc" id="L133">            return null;</span>
<span class="nc" id="L134">        }</span>
    }

    @Override
    public void remove(T tenantId, S rowKey, K columnKey, Timestamper overrideTimestamper) {
<span class="fc" id="L139">        NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(tenantId);</span>
<span class="fc" id="L140">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc" id="L141">            NavigableMap&lt;K, Timestamped&lt;V&gt;&gt; map = store.get(rowKey);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            long timestamp = overrideTimestamper == null ? System.currentTimeMillis() : overrideTimestamper.get();</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if (map == null) {</span>
                // todo should use sortedMap to more closely mimic cassandra impl
<span class="nc" id="L145">                map = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="nc" id="L146">                store.put(rowKey, map);</span>
            }
<span class="fc" id="L148">            Timestamped&lt;V&gt; remove = map.get(columnKey);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (remove == null) {</span>
<span class="nc" id="L150">                remove = new Timestamped&lt;&gt;();</span>
<span class="nc" id="L151">                map.put(columnKey, remove);</span>
            }
<span class="fc" id="L153">            remove.tombstone(timestamp);</span>
<span class="pc" id="L154">        }</span>
<span class="fc" id="L155">    }</span>

    private &lt;R&gt; void get(T tenantId, S rowKey, K startColumnKey, Long maxCount, int batchSize, boolean reversed, CallbackStream&lt;R&gt; callback,
        ValueStoreMarshaller&lt;Map.Entry&lt;K, Timestamped&lt;V&gt;&gt;, R&gt; marshall) {
        try {
<span class="fc" id="L160">            NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(tenantId);</span>

<span class="fc" id="L162">            Map&lt;K, Timestamped&lt;V&gt;&gt; copy = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="fc" id="L163">            synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc" id="L164">                Map&lt;K, Timestamped&lt;V&gt;&gt; map = store.get(rowKey);</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                if (map != null) {</span>
<span class="fc" id="L166">                    copy.putAll(map);</span>
                }
<span class="pc" id="L168">            }</span>

<span class="fc" id="L170">            long count = 0;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            for (Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; e : copy.entrySet()) {</span>
<span class="fc" id="L172">                count++;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                if (e.getValue().isTombstone()) {</span>
<span class="nc" id="L174">                    continue;</span>
                }

<span class="fc" id="L177">                R marshalled = marshall.marshall(e);</span>

                try {
<span class="fc" id="L180">                    R g = callback.callback(marshalled);</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">                    if (g != marshalled) {</span>
<span class="nc" id="L182">                        break;</span>
                    }
<span class="nc" id="L184">                } catch (Exception ex) {</span>
<span class="nc" id="L185">                    throw new CallbackStreamException(ex);</span>
<span class="fc" id="L186">                }</span>

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                if (maxCount != null) {</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">                    if (count &gt;= maxCount) {</span>
<span class="nc" id="L190">                        break;</span>
                    }
                }
<span class="fc" id="L193">            }</span>
            //End of stream
<span class="fc" id="L195">            callback.callback(null);</span>

<span class="nc" id="L197">        } catch (Exception x) {</span>
<span class="nc" id="L198">            throw new RuntimeException(&quot;Failed to get.&quot;, x);</span>
<span class="fc" id="L199">        }</span>
<span class="fc" id="L200">    }</span>

    @Override
    public void getKeys(T tenantId, S rowKey, K startColumnKey, Long maxCount, int batchSize, boolean reversed, Integer overRideNumberOfRetries,
        Integer overrideConsistency, CallbackStream&lt;K&gt; callback) {
<span class="fc" id="L205">        get(tenantId, rowKey, startColumnKey, maxCount, batchSize, reversed, callback, new ValueStoreMarshaller&lt;Map.Entry&lt;K, Timestamped&lt;V&gt;&gt;, K&gt;() {</span>
            @Override
            public K marshall(Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; raw) throws Exception {
<span class="fc" id="L208">                Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; e = raw;</span>
<span class="fc" id="L209">                return e.getKey();</span>
            }
        });
<span class="fc" id="L212">    }</span>

    @Override
    public void getValues(T tenantId, S rowKey, K startColumnKey, Long maxCount, int batchSize, boolean reversed, Integer overRideNumberOfRetries,
        Integer overrideConsistency, CallbackStream&lt;V&gt; callback) {
<span class="fc" id="L217">        get(tenantId, rowKey, startColumnKey, maxCount, batchSize, reversed, callback, new ValueStoreMarshaller&lt;Map.Entry&lt;K, Timestamped&lt;V&gt;&gt;, V&gt;() {</span>
            @Override
            public V marshall(Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; raw) throws Exception {
<span class="fc" id="L220">                Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; e = raw;</span>
<span class="fc" id="L221">                return e.getValue().getValue();</span>
            }
        });
<span class="fc" id="L224">    }</span>

    @Override
    public &lt;TS&gt; void getEntrys(T tenantId, S rowKey, K startColumnKey, Long maxCount, int batchSize, boolean reversed, Integer overRideNumberOfRetries,
        Integer overrideConsistency, CallbackStream&lt;ColumnValueAndTimestamp&lt;K, V, TS&gt;&gt; callback) {
<span class="fc" id="L229">        get(tenantId, rowKey, startColumnKey, maxCount, batchSize, reversed, callback,</span>
<span class="fc" id="L230">            new ValueStoreMarshaller&lt;Map.Entry&lt;K, Timestamped&lt;V&gt;&gt;, ColumnValueAndTimestamp&lt;K, V, TS&gt;&gt;() {</span>
                @Override
                public ColumnValueAndTimestamp&lt;K, V, TS&gt; marshall(Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; raw) throws Exception {
<span class="fc" id="L233">                    Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; e = raw;</span>
<span class="fc" id="L234">                    Object t = e.getValue().getTimestamp();</span>
<span class="fc" id="L235">                    return new ColumnValueAndTimestamp&lt;&gt;(e.getKey(), e.getValue().getValue(), (TS) t);</span>
                }
            });
<span class="fc" id="L238">    }</span>

    @Override
    public void multiRowsMultiAdd(T tenantId, List&lt;RowColumValueTimestampAdd&lt;S, K, V&gt;&gt; multiAdd) {
<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (RowColumValueTimestampAdd&lt;S, K, V&gt; add : multiAdd) {</span>
<span class="fc" id="L243">            add(tenantId, add.getRowKey(), add.getColumnKey(), add.getColumnValue(), null, add.getOverrideTimestamper());</span>
<span class="fc" id="L244">        }</span>
<span class="fc" id="L245">    }</span>

    @Override
    public void multiRowsMultiAdd(List&lt;TenantRowColumValueTimestampAdd&lt;T, S, K, V&gt;&gt; multiAdd) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (TenantRowColumValueTimestampAdd&lt;T, S, K, V&gt; add : multiAdd) {</span>
<span class="nc" id="L250">            add(add.getTenantId(),</span>
                add.getRowKey(),
                add.getColumnKey(),
                add.getColumnValue(),
                null,
                add.getOverrideTimestamper());
<span class="nc" id="L256">        }</span>
<span class="nc" id="L257">    }</span>

    @Override
    public void multiAdd(T tenantId, S rowKey, K[] columnKeys, V[] columnValues, Integer timeToLiveInSeconds, Timestamper overrideTimestamper) {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (columnKeys.length != columnValues.length) {</span>
<span class="nc" id="L262">            throw new RuntimeException(&quot;keys.length must equal values.length&quot;);</span>
        }
<span class="fc" id="L264">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            for (int i = 0; i &lt; columnKeys.length; i++) {</span>
<span class="fc" id="L266">                add(tenantId, rowKey, columnKeys[i], columnValues[i], timeToLiveInSeconds, overrideTimestamper);</span>
            }
<span class="pc" id="L268">        }</span>
<span class="fc" id="L269">    }</span>

    @Override
    public List&lt;V&gt; multiGet(T tenantId, S rowKey, K[] columnKeys, Integer overrideNumberOfRetries, Integer overrideConsistency) {
<span class="fc" id="L273">        List&lt;V&gt; got = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L274">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">            for (K k : columnKeys) {</span>
<span class="fc" id="L276">                got.add(get(tenantId, rowKey, k, overrideNumberOfRetries, overrideConsistency));</span>
            }
<span class="pc" id="L278">        }</span>
<span class="fc" id="L279">        return got;</span>
    }

    /**
     *
     * @param tenantId
     * @param rowKey
     * @param columnKeys
     * @param overrideNumberOfRetries
     * @param overrideConsistency
     * @return array size is the same size as columnKeys and indexes are stable.
     */
    @Override
    public ColumnValueAndTimestamp&lt;K, V, Long&gt;[] multiGetEntries(T tenantId, S rowKey, K[] columnKeys, Integer overrideNumberOfRetries,
        Integer overrideConsistency) {

<span class="fc" id="L295">        NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(tenantId);</span>
<span class="fc" id="L296">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc" id="L297">            Map&lt;K, Timestamped&lt;V&gt;&gt; map = store.get(rowKey);</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            if (map == null) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                return new ColumnValueAndTimestamp[columnKeys != null ? columnKeys.length : 0];</span>
            }
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            Collection&lt;K&gt; keysToIterate = (columnKeys != null) ? Arrays.asList(columnKeys) : map.keySet();</span>
<span class="fc" id="L302">            List&lt;ColumnValueAndTimestamp&lt;K, V, Long&gt;&gt; got = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            for (K columnKey : keysToIterate) {</span>
<span class="fc" id="L304">                Timestamped&lt;V&gt; value = map.get(columnKey);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">                if (value == null) {</span>
<span class="fc" id="L306">                    got.add(null);</span>
                } else {
<span class="fc bfc" id="L308" title="All 2 branches covered.">                    if (value.isTombstone()) {</span>
<span class="fc" id="L309">                        got.add(null);</span>
                    } else {
<span class="fc" id="L311">                        got.add(new ColumnValueAndTimestamp&lt;&gt;(columnKey, value.getValue(), value.getTimestamp()));</span>
                    }
                }
<span class="fc" id="L314">            }</span>
<span class="fc" id="L315">            return got.toArray(new ColumnValueAndTimestamp[got.size()]);</span>

<span class="nc" id="L317">        }</span>

    }

    @Override
    public void multiRemove(T tenantId, S rowKey, K[] columnKeys, Timestamper overrideTimestamper) {
<span class="fc" id="L323">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">            for (K k : columnKeys) {</span>
<span class="fc" id="L325">                remove(tenantId, rowKey, k, overrideTimestamper);</span>
            }
<span class="pc" id="L327">        }</span>
<span class="fc" id="L328">    }</span>

    @Override
    public void multiRowsMultiRemove(T tenantId, List&lt;RowColumnTimestampRemove&lt;S, K&gt;&gt; multiRemove) {
<span class="fc bfc" id="L332" title="All 2 branches covered.">        for (RowColumnTimestampRemove&lt;S, K&gt; remove : multiRemove) {</span>
<span class="fc" id="L333">            remove(tenantId, remove.getRowKey(), remove.getColumnKey(), remove.getOverrideTimestamper());</span>
<span class="fc" id="L334">        }</span>
<span class="fc" id="L335">    }</span>

    @Override
    public void multiRowsMultiRemove(List&lt;TenantRowColumnTimestampRemove&lt;T, S, K&gt;&gt; multiRemove) {
<span class="nc bnc" id="L339" title="All 2 branches missed.">        for (TenantRowColumnTimestampRemove&lt;T, S, K&gt; remove : multiRemove) {</span>
<span class="nc" id="L340">            remove(remove.getTenantId(),</span>
                remove.getRowKey(),
                remove.getColumnKey(),
                remove.getOverrideTimestamper());
<span class="nc" id="L344">        }</span>
<span class="nc" id="L345">    }</span>

    @Override
    public void getAllRowKeys(int batchSize, Integer overrideNumberOfRetries, CallbackStream&lt;TenantIdAndRow&lt;T, S&gt;&gt; callback) {
<span class="nc" id="L349">        getRowKeys(null, null, null, batchSize, overrideNumberOfRetries, callback);</span>
<span class="nc" id="L350">    }</span>

    @Override
    public void getRowKeys(T tenantId, S startRowKey, S stopRowKey, int batchSize, Integer overrideNumberOfRetries,
        CallbackStream&lt;TenantIdAndRow&lt;T, S&gt;&gt; callback) {
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (tenantId != null) {</span>
<span class="nc" id="L356">            NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(tenantId);</span>
<span class="nc" id="L357">            getRowKeysForTenant(tenantId, store, startRowKey, stopRowKey, batchSize, overrideNumberOfRetries, callback);</span>
<span class="nc" id="L358">        } else {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            for (Entry&lt;T, NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt;&gt; entry : tenantIdStores.entrySet()) {</span>
<span class="nc" id="L360">                getRowKeysForTenant(entry.getKey(), entry.getValue(), startRowKey, stopRowKey, batchSize, overrideNumberOfRetries, callback);</span>
<span class="nc" id="L361">            }</span>
        }

        try {
<span class="nc" id="L365">            callback.callback(null);</span>
<span class="nc" id="L366">        } catch (Exception ex) {</span>
<span class="nc" id="L367">            LOG.error(&quot;calling callback EOS.&quot;, ex);</span>
<span class="nc" id="L368">        }</span>
<span class="nc" id="L369">    }</span>

    private void getRowKeysForTenant(T tenantId, NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; rows, S startRowKey, S stopRowKey, int batchSize,
        Integer overrideNumberOfRetries, CallbackStream&lt;TenantIdAndRow&lt;T, S&gt;&gt; callback) {
        NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; rowsFromStart;
<span class="nc bnc" id="L374" title="All 2 branches missed.">        rowsFromStart = startRowKey != null ? rows.tailMap(startRowKey, true) : rows;</span>

        NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; rowsInRange;
<span class="nc bnc" id="L377" title="All 2 branches missed.">        rowsInRange = stopRowKey != null ? rowsFromStart.headMap(stopRowKey, false) : rowsFromStart;</span>

<span class="nc bnc" id="L379" title="All 2 branches missed.">        for (S row : rowsInRange.keySet()) {</span>
<span class="nc" id="L380">            synchronized (rowLocks.lock(row)) {</span>
<span class="nc" id="L381">                TenantIdAndRow&lt;T, S&gt; rowKey = new TenantIdAndRow&lt;&gt;(tenantId, row);</span>
<span class="nc" id="L382">                TenantIdAndRow&lt;T, S&gt; returned = null;</span>
                try {
<span class="nc" id="L384">                    returned = callback.callback(rowKey);</span>
<span class="nc" id="L385">                } catch (Exception ex) {</span>
<span class="nc" id="L386">                    LOG.error(&quot;calling callback.&quot;, ex);</span>
<span class="nc" id="L387">                }</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                if (returned != rowKey) {</span>
<span class="nc" id="L389">                    break;</span>
                }
<span class="nc" id="L391">            }</span>
<span class="nc" id="L392">        }</span>
<span class="nc" id="L393">    }</span>

    @Override
    public void removeRow(T tenantId, S rowKey, Timestamper overrideTimestamper) {
<span class="fc" id="L397">        NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(tenantId);</span>
<span class="fc" id="L398">        synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc" id="L399">            Map&lt;K, Timestamped&lt;V&gt;&gt; columns = store.get(rowKey);</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            if (columns != null) {</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                for (Entry&lt;K, Timestamped&lt;V&gt;&gt; c : columns.entrySet()) {</span>
<span class="fc" id="L402">                    remove(tenantId, rowKey, c.getKey(), overrideTimestamper);</span>
<span class="fc" id="L403">                }</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">                if (columns.isEmpty()) {</span>
<span class="nc" id="L405">                    store.remove(rowKey);</span>
                }
            }
<span class="pc" id="L408">        }</span>
<span class="fc" id="L409">    }</span>

    @Override
    public List&lt;V&gt; multiRowGet(T tenantId, List&lt;S&gt; rowKeys, K columnKey, Integer overrideNumberOfRetries, Integer overrideConsistency) {
<span class="nc" id="L413">        List&lt;V&gt; values = new ArrayList&lt;&gt;(rowKeys.size());</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        for (S rowKey : rowKeys) {</span>
<span class="nc" id="L415">            values.add(get(tenantId, rowKey, columnKey, overrideNumberOfRetries, overrideConsistency));</span>
<span class="nc" id="L416">        }</span>
<span class="nc" id="L417">        return values;</span>
    }

    @Override
    public List&lt;Map&lt;K, V&gt;&gt; multiRowMultiGet(T tenantId, List&lt;S&gt; rowKeys, List&lt;K&gt; columnKeys, Integer overrideNumberOfRetries, Integer overrideConsistency) {
<span class="nc" id="L422">        List&lt;Map&lt;K, V&gt;&gt; result = new ArrayList&lt;&gt;(rowKeys.size());</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        for (S rowKey : rowKeys) {</span>
<span class="nc" id="L424">            List&lt;V&gt; values = multiGet(tenantId, rowKey, (K[]) columnKeys.toArray(), overrideNumberOfRetries, overrideConsistency);</span>
<span class="nc" id="L425">            Map&lt;K, V&gt; valuesMap = new HashMap&lt;&gt;(columnKeys.size());</span>
<span class="nc" id="L426">            result.add(valuesMap);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">            for (int i = 0; i &lt; columnKeys.size(); i++) {</span>
<span class="nc" id="L428">                K key = columnKeys.get(i);</span>
<span class="nc" id="L429">                valuesMap.put(key, values.get(i));</span>
            }
<span class="nc" id="L431">        }</span>
<span class="nc" id="L432">        return result;</span>
    }

    @Override
    public &lt;TS&gt; void multiRowGetAll(T tenantId, List&lt;KeyedColumnValueCallbackStream&lt;S, K, V, TS&gt;&gt; rowKeyCallbackStreamPairs) {
<span class="fc" id="L437">        NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(tenantId);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        for (KeyedColumnValueCallbackStream&lt;S, K, V, TS&gt; pair : rowKeyCallbackStreamPairs) {</span>
<span class="fc" id="L439">            S rowKey = pair.getKey();</span>

<span class="fc" id="L441">            Map&lt;K, Timestamped&lt;V&gt;&gt; copy = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="fc" id="L442">            synchronized (rowLocks.lock(rowKey)) {</span>
<span class="fc" id="L443">                Map&lt;K, Timestamped&lt;V&gt;&gt; map = store.get(pair.getKey());</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">                if (map != null) {</span>
<span class="fc" id="L445">                    copy.putAll(map);</span>
                }
<span class="pc" id="L447">            }</span>

            try {
<span class="fc" id="L450">                CallbackStream&lt;ColumnValueAndTimestamp&lt;K, V, TS&gt;&gt; callbackStream = pair.getCallbackStream();</span>

<span class="fc bfc" id="L452" title="All 2 branches covered.">                for (Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; columnAndTimestamped : copy.entrySet()) {</span>
<span class="fc" id="L453">                    K column = columnAndTimestamped.getKey();</span>
<span class="fc" id="L454">                    Timestamped&lt;V&gt; got = columnAndTimestamped.getValue();</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                    if (got.isTombstone()) {</span>
<span class="nc" id="L456">                        continue;</span>
                    }

                    try {
<span class="fc" id="L460">                        ColumnValueAndTimestamp&lt;K, V, TS&gt; cvat = new ColumnValueAndTimestamp&lt;&gt;(column, got.getValue(), (TS) (Object) got.getTimestamp());</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">                        if (callbackStream.callback(cvat) != cvat) {</span>
<span class="nc" id="L462">                            break;</span>
                        }
<span class="nc" id="L464">                    } catch (Exception ex) {</span>
<span class="nc" id="L465">                        throw new CallbackStreamException(ex);</span>
<span class="fc" id="L466">                    }</span>
<span class="fc" id="L467">                }</span>

                //eos
<span class="fc" id="L470">                callbackStream.callback(null);</span>

<span class="nc" id="L472">            } catch (Exception ex) {</span>
<span class="nc" id="L473">                throw new RuntimeException(ex);</span>

<span class="fc" id="L475">            }</span>
<span class="fc" id="L476">        }</span>
<span class="fc" id="L477">    }</span>

    @Override
    public &lt;TS&gt; void multiRowGetAll(List&lt;TenantKeyedColumnValueCallbackStream&lt;T, S, K, V, TS&gt;&gt; rowKeyCallbackStreamPairs) {

<span class="nc bnc" id="L482" title="All 2 branches missed.">        for (TenantKeyedColumnValueCallbackStream&lt;T, S, K, V, TS&gt; pair : rowKeyCallbackStreamPairs) {</span>
<span class="nc" id="L483">            NavigableMap&lt;S, NavigableMap&lt;K, Timestamped&lt;V&gt;&gt;&gt; store = getStore(pair.getTenantId());</span>
<span class="nc" id="L484">            S rowKey = pair.getKey();</span>
<span class="nc" id="L485">            Map&lt;K, Timestamped&lt;V&gt;&gt; copy = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="nc" id="L486">            synchronized (rowLocks.lock(rowKey)) {</span>
<span class="nc" id="L487">                Map&lt;K, Timestamped&lt;V&gt;&gt; map = store.get(pair.getKey());</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                if (map != null) {</span>
<span class="nc" id="L489">                    copy.putAll(map);</span>
                }
<span class="nc" id="L491">            }</span>

            try {
<span class="nc" id="L494">                CallbackStream&lt;ColumnValueAndTimestamp&lt;K, V, TS&gt;&gt; callbackStream = pair.getCallbackStream();</span>

<span class="nc bnc" id="L496" title="All 2 branches missed.">                for (Map.Entry&lt;K, Timestamped&lt;V&gt;&gt; columnAndTimestamped : copy.entrySet()) {</span>
<span class="nc" id="L497">                    K column = columnAndTimestamped.getKey();</span>
<span class="nc" id="L498">                    Timestamped&lt;V&gt; got = columnAndTimestamped.getValue();</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    if (got.isTombstone()) {</span>
<span class="nc" id="L500">                        continue;</span>
                    }

                    try {
<span class="nc" id="L504">                        ColumnValueAndTimestamp&lt;K, V, TS&gt; cvat = new ColumnValueAndTimestamp&lt;&gt;(column, got.getValue(), (TS) (Object) got.getTimestamp());</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                        if (callbackStream.callback(cvat) != cvat) {</span>
<span class="nc" id="L506">                            break;</span>
                        }
<span class="nc" id="L508">                    } catch (Exception ex) {</span>
<span class="nc" id="L509">                        throw new CallbackStreamException(ex);</span>
<span class="nc" id="L510">                    }</span>
<span class="nc" id="L511">                }</span>

                //eos
<span class="nc" id="L514">                callbackStream.callback(null);</span>
<span class="nc" id="L515">            } catch (Exception ex) {</span>
<span class="nc" id="L516">                throw new RuntimeException(ex);</span>
<span class="nc" id="L517">            }</span>

<span class="nc" id="L519">        }</span>
<span class="nc" id="L520">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>